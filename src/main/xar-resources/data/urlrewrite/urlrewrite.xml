<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?><?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?><article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>URL Rewriting</title>
    <date>2022-02</date>
    <keywordset>
      <keyword>application-development</keyword>
    </keywordset>
  </info>

  <!-- ================================================================== -->
  <para>How to use <code>controller.xq</code> files to map URIs to resources in exist-db.</para>
  <!-- ================================================================== -->

  <sect1 xml:id="intro">
    <title>Introduction</title>
    <para>Good web applications provide meaningful, consistent URIs to the user. <emphasis>URL rewriting</emphasis> is one way to provide short, human-readable URIs that provide access to the often complex heirarchy of XQuery modules, HTML files data and other resources that are combined into an application.</para>
    <para>A typical URL rewriting operation might be handled as follows:</para>
    <orderedlist>
        <listitem>
          <para>eXist receives a HTTP request; in the default configuration this is handled by the <code>XQueryUrlRewrite</code> servlet for any URI starting with the path <code>/exist</code>.</para>
        </listitem>
        <listitem>
          <para>The <code>XQueryUrlRewrite</code> servlet looks for an XQuery script to interpret the rest of the URI (see <xref linkend="controller-mappings"/>).  By convention this is called <code>controller.xq</code> (or in older applications <code>controller.xql</code>).  The default configuration will work with a script saved with this name in the base collection of an application.</para>
        </listitem>
        <listitem>
          <para><code>controller.xq</code> examines the URI using pre-defined <xref linkend="variables"/>, and produces a fragment in the <xref linkend="controller-xml"/>.</para>
        </listitem>
        <listitem>
          <para><code>XQueryURLRewrite</code> uses the controller XML fragment as an instruction on what to do next.  This instruction may be as simple as forwarding to a resource on (or off) the server, or it may be as complex as a pipeline using the <emphasis>Model-View-Controller</emphasis> pattern (see <xref linkend="mvc-pipelines"/>) and other servlets such as eXist's <xref linkend="xq-servlet"/> or <xref linkend="xslt-servlet"/>.</para>
        </listitem>
      </orderedlist>
    <sect2 xml:id="eg1">
      <title>Example 1: A Simple Implementation</title>
      <para>Consider a document similar to the one you are currently reading; a direct URL pointing to the source data might be <code>/exist/apps/doc/data/urlrewrite.xml</code>. But accessing this URI would only show a user the raw XML: instead users should get a properly formatted HTML version of the text, accessible through a simple URL like <code>/exist/apps/doc/urlrewrite</code>.</para>
      <para>To achieve this we need a mechanism to map or rewrite a given URL to an application specific endpoint. So in the simplest case, calling <code>/exist/apps/doc/urlrewrite</code> would locate the source document, transform it into HTML and return the result.</para>
      <para><literal>controller.xq</literal> is invoked for all URL paths targeting the collection in which it resides. It has access to a number of <xref linkend="variables"/> pre-filled with details about the request, including <literal>$exist:resource</literal>, containing the name of the resource (without path components) the request tries to access; also the <literal>$exist:controller</literal> variable which points to the collection the <literal>controller.xq</literal> is located in.</para>
      <para>For example, one may want to direct all requests to <literal>/exist/apps/doc/{resource}</literal> to an XQuery, <literal>transform.xq</literal>, which is responsible for converting the XML content into HTML:</para>
      <programlisting language="xquery" xlink:href="listings/listing-1.txt"/>
      <para>This example controller returns a simple <tag>dispatch</tag> fragment which will be passed back to the URL rewriting framework. The <tag>forward</tag> element instructs the framework to call the URL <literal>modules/transform.xq</literal> relative to the collection in which the controller resides. It adds a request parameter, named <literal>doc</literal>, which indicates the resource to be transformed.  The receiving query could access this parameter using <code>request:get-parameter("doc", ())</code> in order to retrieve the requested article.</para>
    </sect2>
    <sect2 xml:id="eg2">
      <title>Example 2: Defining a Pipeline</title>
      <para>Real world controllers are typically more complex and may contain arbitrary XQuery code to distinguish between different scenarios. The URL rewriting framework allows you to turn simple requests into complex processing pipelines, involving any number of steps.</para>
      <para>For example, let us split above <tag>dispatch</tag> fragment into a pipeline involving two steps:</para>
      <orderedlist>
        <listitem>
          <para>load the resource to be transformed</para>
        </listitem>
        <listitem>
          <para>pass the content of the resource to <literal>modules/transform.xq</literal></para>
        </listitem>
      </orderedlist>
      <programlisting language="xquery" xlink:href="listings/listing-2.txt"/>
      <para>Every <tag>dispatch</tag> fragment must contain at least one step, followed by an optional <tag>view</tag> element grouping any number of follow up steps. In the example, the first <tag>forward</tag> step simply loads the XML document requested and returns its content. The output of the first step is passed to the second step via the HTTP request (and can be accessed via the XQuery function <code>request:get-data()</code>).</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->
  <sect1 xml:id="controller-xml">
    <title>Controller XML Format</title>
    <para>As we've seen, <code>controller.xq</code> is expected to return a single XML document, the root element of which must be either <tag>dispatch xmlns="http://exist.sourceforge.net/NS/exist"</tag>, or <tag>ignore xmlns="http://exist.sourceforge.net/NS/exist"</tag>. </para>
    <para>Note that all of the elements discussed in this statement must be in this <code>http://exist.sourceforge.net/NS/exist</code> namespace.</para>
    <para>The <tag>dispatch</tag> element must contain one of the <emphasis>action elements</emphasis>
      <link linkend="redirect"><literal>redirect</literal></link> or <link linkend="forward"><literal>forward</literal></link>, followed by an optional <link linkend="view"><literal>view</literal></link> action. It may also contain an optional <link linkend="cache-control"><literal>cache-control</literal></link> element.</para>
    <sect2 xml:id="ignore">
      <title>The <tag>ignore</tag> Action</title>
      <para>The <tag>ignore</tag> action simply bypasses the URL rewriting process. This may be useful for requests to fixed resources like images or stylesheets. An alternative may be to handle requests for such resources separately from the <code>XQueryUrlRewrite</code> servlet; this is discussed in <xref linkend="controller-mappings"/>.</para>
      <programlisting language="xml">&lt;ignore xmlns="http://exist.sourceforge.net/NS/exist"/&gt;</programlisting>
      <para>The <tag>ignore</tag> element may include an optional <link linkend="cache-control"><literal>cache-control</literal></link> element.</para>
    </sect2>
    <sect2 xml:id="redirect">
      <title>The <tag>redirect</tag> Action</title>
      <para>The <tag>redirect</tag> Action redirects the client to another URL, indicating that the other URL must be used for subsequent requests. Note that this causes the client to issue a new request, potentially triggering the controller again; care should be taken to avoid looping behaviours.</para>
      <para>The URL to redirect to is given in attribute <literal>url</literal>. </para>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;redirect url="..."/&gt;
&lt;/dispatch&gt;</programlisting>
      <para>A redirect will be visible to the user: for instance the user's browser will be updated to show the specified new URL.</para>
    </sect2>
    <sect2 xml:id="forward">
      <title>The <tag>forward</tag> Action</title>
      <para>The <tag>forward</tag> Action forwards the current request to another request path or servlet. The forwarding is done on the server only (via the <code>RequestDispatcher</code> of the servlet engine). The client can't see where the request was forwarded to.</para>
      <para>The element is allowed the following attributes, and must define either <literal>url</literal> or <literal>servlet</literal>:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>url</code>
          </term>
          <listitem>
            <para>The new request path, which will be processed by the servlet engine in the normal way, as if it were directly called.</para>
            <para>A relative path will be relative to the current request path. An absolute path will be resolved relative to the path that triggered the controller.</para>
            <para>For example, if the current web context is <literal>/exist</literal> and the supplied attribute reads <literal>url="/admin"</literal>, the resulting path will be <literal>/exist/admin</literal>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>servlet</code>
          </term>
          <listitem>
            <para>The name of a servlet as given in the <tag>servlet-name</tag> element in the corresponding servlet definition of the web descriptor <literal>web.xml</literal>. </para>
            <para>For example, valid names within the eXist standard setup would be <code>XQueryServlet</code> or <code>XSLTServlet</code>. See some examples of these in <xref linkend="mvc-pipelines"/>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>absolute</code>
          </term>
          <listitem>
            <para>To be used in combination with <literal>url</literal>. If set to "yes", the url will be interpreted as an absolute path within the current servlet context. See <xref linkend="EXTERNAL_RESOURCES"/> for an example.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>method</code>
          </term>
          <listitem>
            <para>The HTTP method (POST, GET, PUT ...) to use when passing the request to the next step in a pipeline (and so does not apply to the first step). The default method for pipeline steps in the view section is always POST.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;forward url="{$exist:controller}/modules/transform.xq"&gt;
    &lt;add-parameter name="doc" value="{$exist:resource}.xml"/&gt;
  &lt;/forward&gt;
&lt;/dispatch&gt;</programlisting>
      <para>The <tag>forward</tag> element can contain the optional children elements <link linkend="add-parameter"><literal>add-parameter</literal></link>, <link linkend="set-attribute"><literal>set-attribute</literal></link>, <link linkend="clear-attribute"><literal>clear-attribute</literal></link>, and <link linkend="set-header"><literal>set-header</literal></link>.</para>
    </sect2>
    <sect2 xml:id="view">
      <title>The <tag>view</tag> Action</title>
      <para>The <tag>view</tag> action is used to define processing pipelines, and may follow <link linkend="redirect"><literal>redirect</literal></link> or <link linkend="forward"><literal>forward</literal></link> actions.</para>
      <para>The element is used to wrap a sequence of action elements such as <link linkend="forward"><literal>forward</literal></link>, often calling another servlet to process the results of the initial action.  This is discussed in <xref linkend="mvc-pipelines"/></para>
    </sect2>
    <sect2 xml:id="add-parameter">
      <title>The <tag>add-parameter</tag> Option</title>
      <para>The <tag>add-parameter</tag> option adds (or overwrites) a request parameter.</para>
      <para>The name of the parameter is taken from attribute <literal>name</literal>, the value from attribute <literal>value</literal>.</para>
      <programlisting language="xml">&lt;add-parameter name="xxx" value="yyy"/&gt;</programlisting>
      <para>The original HTTP request will be copied before the change is applied. Subsequent steps in the pipeline will not see the parameter. </para>
    </sect2>
    <sect2 xml:id="set-attribute">
      <title>The <tag>set-attribute</tag> Option</title>
      <para>The <tag>set-attribute</tag> option sets a request attribute to the given value.</para>
      <para>The name of the request attribute is read from  <literal>name</literal>, the value from  <literal>value</literal>.</para>
      <programlisting language="xml">&lt;set-attribute name="xxx" value="yyy"/&gt;</programlisting>
      <para>You can set arbitrary request attributes, for instance to pass information between XQueries. Some attributes may be reserved by called servlets.</para>
    </sect2>
    <sect2 xml:id="clear-attribute"><title>The <tag>clear-attribute</tag> Option</title>
      <para>The <tag>clear-attribute</tag> option clears a request attribute.</para>
      <para>The name of the request attribute is read from the XML attribute <literal>name</literal>.</para>
      <programlisting language="xml">&lt;clear-attribute name="xxx"/&gt;</programlisting>
      <para>Unlike parameters, request attributes will be visible to subsequent steps in the processing pipeline. They need to be cleared once they are no longer needed. </para></sect2>
    <sect2 xml:id="set-header"><title>The <tag>set-header</tag> Option</title>
      <para>The <tag>set-header</tag> option sets an HTTP response header field.</para>
      <para>The name of the header is read from attribute <literal>name</literal>, the value from attribute <literal>value</literal>.</para>
      <programlisting language="xml">&lt;set-header name="xxx" value="yyy"/&gt;</programlisting>
      <para>The HTTP response is shared between all steps in the pipeline, so all following steps will be able to see the change.</para></sect2>
    <sect2 xml:id="cache-control">
      <title>The <tag>cache-control</tag> Option</title>
      <para>The <tag>cache-control</tag> element is used to tell XQueryURLRewrite if the current URL rewrite should be cached. It has a single attribute <literal>cache="yes|no"</literal>. </para>
      <para>Internally, XQueryURLRewrite keeps a map of input URIs to dispatch rules. With the cache enabled, the controller XQuery only needs to be executed once for every input URI. Subsequent requests will use the cache.</para>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;redirect url="..."/&gt;
  &lt;cache-control cache="yes"/&gt;
&lt;/dispatch&gt;</programlisting>
      <para>Watch out: only the URL rewrite rule is cached, not the HTTP response. The cache-control setting has nothing to do with the corresponding HTTP cache headers or client-side caching within the browser</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="variables">
    <title>Controller Variables</title>
    <para>Several variables are made available to the <code>controller.xq</code> script; for example, if the request path is <literal>/exist/tools/sandbox/get-examples.xq</literal> the following variables populated:</para>
    <table>
      <title>Table title</title>
      <tgroup cols="2">
        <colspec/>
        <colspec/>
        <thead>
          <row>
            <entry>Variable</entry>
            <entry>Contents</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal>$exist:prefix</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/tools</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:controller</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/sandbox</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:path</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/get-examples.xq</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:resource</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>get-examples.xml</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:root</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>xmldb:exist:///db</literal>
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>You do not need to explicitly declare the variables or the namespace. However you can add an external declaration for these variables at the top of your XQuery. For instance:</para>
    <programlisting language="xquery">declare variable $exist:path as external;</programlisting>
    <variablelist>
      <varlistentry>
        <term>
          <code>exist:path</code>
        </term>
        <listitem>
          <para>The last part of the request URI after the section leading to the controller. </para>
          <para>For instance: If the resource <literal>example.xml</literal> resides within the same directory as the controller query, <literal>$exist:path</literal> will be <literal>/example.xml</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><code>exist:resource</code></term>
        <listitem>
          <para>The section of the URI after the last <literal>/</literal>, usually pointing to a resource. </para>
          <para>For instance: <literal>example.xml</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:controller</code>
        </term>
        <listitem>
          <para>The part of the URI leading to the current controller script.</para>
          <para>For example: if the request path is <literal>/xquery/test.xq</literal> and the controller is in the <literal>xquery</literal> collection, <literal>$exist:controller</literal> will contain <literal>/xquery</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:prefix</code>
        </term>
        <listitem>
          <para>If the current controller hierarchy is mapped to a certain path prefix, <literal>$exist:prefix</literal> returns that prefix.</para>
          <para> For example: the default configuration maps the path <literal>/tools</literal> to a collection in the database (see below). In this case, <literal>$exist:prefix</literal> would contain <literal>/tools</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:root</code>
        </term>
        <listitem>
          <para>The root of the current controller hierarchy. This may either point to the file system or to a collection in the database. Use this variable to locate resources relative to the root of the application.</para>
          <para> For example: assume you want to process a request using stylesheet <literal>db2xhtml.xsl</literal>, which could <emphasis>either</emphasis> be stored in the <literal>/stylesheets</literal> directory in the root of the webapp or, if the app is running from within the database, the corresponding <literal>/stylesheets</literal> collection. You want your app to be able to run from either location. The solution is to use <literal>exist:root</literal>:</para>
          <programlisting language="xml" xlink:href="listings/listing-5.xml"/>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>These variables are recommended for simplicity and convenience; however note that within a <code>controller.xq</code> file, you also have access to the entire XQuery function library, including the functions in the <code>request</code>, <code>response</code> and <code>session</code> modules.</para>
  </sect1>

  <!-- ================================================================== -->
  <sect1 xml:id="EXTERNAL_RESOURCES">
    <title>Accessing resources not stored in the database</title>
    <para>If your <code>controller.xq</code> is stored in a database collection, all relative and/or absolute URIs within the controller will be resolved against the database, not the file system. This can be a problem if you need to access common resources, which should be shared with other applications residing on the file system or in the database.</para>
    <para>The <link linkend="forward"><literal>forward</literal></link> directive accepts an optional attribute <literal>absolute="yes|no"</literal> to handle this. If one sets <literal>absolute="yes"</literal>, an absolute path (starting with a <code>/</code>) in the <literal>url</literal> attribute will resolve relative to the current servlet context, not the controller context.</para>
    <para>For example, to forward all requests starting with a path <literal>/libs/</literal> to a directory within the <literal>webapp</literal> folder of eXist, you can use the following snippet:</para>
    <programlisting language="xquery" xlink:href="listings/listing-12.txt"/>
    <para>This simply removes the /libs/ prefix and sets absolute="yes", so the path will be resolved relative to the main context of the servlet engine, usually /exist/. In your HTML, you can now write:</para>
    <programlisting language="xml" xlink:href="listings/listing-13.xml"/>
    <para>This will locate the jquery file in <literal>webapp/scripts/jquery/...</literal>, even if the rest of your application is stored in the db and not on the file system.</para>
  </sect1>
  <!-- ================================================================== -->

  <sect1 xml:id="controller-mappings">
    <title>Locating Controller Scripts and Configuring Base Mappings</title>

    <para>By convention, the controller XQueries are called <literal>controller.xq</literal>.  Note that other users (i.e. <code>guest</code>) will need to have execute permissions for this file.</para>
    <para>By default, <code>XQueryURLRewrite</code> will try to guess the path to the controller by looking at the request path, starting with the most specific collection, and looking in each parent collection until the controller is found.</para>
    <para>This can be configured and over-ridden in the <literal>controller-config.xml</literal> file in <literal>etc/webapp/WEB-INF</literal>, which defines the base mappings used.</para>

    <para>In fact, one web application may have more than one controller hierarchy. For example, you may want to keep the main webapp within the file system, while some tools and scripts should be served from a database collection. This can be done by configuring two roots within the <literal>controller-config.xml</literal> file.</para>
    <para>It has two components:</para>
    <itemizedlist>
      <listitem>
        <para>
          <tag>forward</tag>
          actions which map patterns to servlets</para>
      </listitem>
      <listitem>
        <para>
          <tag>root</tag>
          elements define the root for a file system or db collection hierarchy
        </para>
      </listitem>
    </itemizedlist>
    <para>The
      <tag>forward</tag>
      tags specify path mappings for common servlets, similar to a servlet mapping in
      <literal>web.xml</literal>. The advantage is that XQueryURLRewrite becomes a single point of entry for the entire web application and we don't need to handle any of the servlet paths in the main controller. For example, if we registered a servlet mapping for
      <literal>/rest</literal>
      in
      <literal>web.xml</literal>, we would need to make sure that this path is ignored in our main
      <literal>controller.xq</literal>. However, if the mapping is done via
      <literal>controller-config.xml</literal>, it will already been known to XQueryURLRewrite and we don't need take care of the path in our controller.</para>
    <para>The
      <tag>root</tag>
      elements define the roots of a directory or database collection hierarchy, mapped to a certain base path. For example, the default
      <literal>controller-config.xml</literal>
      uses two roots:</para>
    <programlisting language="xml" xlink:href="listings/listing-7.txt"/>
    <para>This means that paths starting with
      <literal>/tools</literal>
      will be mapped to the collection hierarchy below
      <literal>/db/www</literal>. Everything else is handled by the catch all pattern pointing to the root directory of the webapp (by default corresponding to
      <literal>$EXIST_HOME/etc/webapp</literal>). For example, the URI</para>
    <programlisting>http://localhost:8080/exist/tools/admin/admin.xq</programlisting>
    <para>will be handled by the controller stored in database collection
      <literal>/db/www/admin/</literal>
      (if there is one) or will directly resolve to
      <literal>/db/www/admin/admin.xq</literal>. In this case, all relative or absolute URIs within the controller will be resolved against the database, not the file system. However, there's a possibility to escape this path interpretation, described
      <link xlink:href="#EXTERNAL_RESOURCES">below</link>.</para>
  </sect1>
  <!-- ================================================================== -->

  <sect1 xml:id="mvc-pipelines">
    <title>MVC and Pipelines</title>

    <para>
      <code>XQueryURLRewrite</code>
      does more than just forward or redirect requests: the response can be processed by passing it to a pipeline of views. "Views" are again just plain Java servlets. The most common use of a view would be to post-processes the XML returned from the
      primary URL, either through another XQuery or an XSLT stylesheet (<code>XSLTServlet</code>).
      <code>XQueryURLRewrite</code>
      passes the HTTP response stream of the previous servlet to the HTTP request received by the next servlet.
    </para>
    <para>Views may also directly exchange information through the use of request attributes (more on that below).</para>

    <para>You define a view pipeline by adding a
      <tag>view</tag>
      element to the
      <tag>dispatch</tag>
      fragment returned by the controller. The
      <tag>view</tag>
      element is a wrapper around another sequence of
      <tag>forward</tag>
      or
      <tag>rewrite</tag>
      actions.</para>
    <para>For example, assume we have XML written in docbook format and want to show this as HTML by sending this through an XSLT stylesheet
      <literal>webapp/stylesheets/db2html.xsl</literal>. This can be done by returning the following
      <tag>dispatch</tag>
      fragment by
      <literal>controller.xq</literal>:</para>
    <programlisting language="xml" xlink:href="listings/listing-9.xml"/>
    <para>In this example there's no forwarding action except for the view, So the request will be handled by the servlet engine the normal way. The response is then passed to
      <code>XSLTServlet</code>. A new HTTP POST request is created whose body is set to the response data of the previous step.
      <code>XSLTServlet</code>
      gets the path to the stylesheet from the request attribute
      <code>xslt.stylesheet</code>
      and applies it to the data.</para>
    <para>If any step in the pipeline generates an error or returns an HTTP status code &gt;= 400, the pipeline processing stops and the response is send back to the client immediately. The same happens if the first step returns with an HTTP status 304
      (NOT MODIFIED), which indicates that the client can use the version it has cached.</para>
    <para>We can also pass a request through more than one view. The following fragment applies two stylesheets in sequence:</para>

    <programlisting language="xquery" xlink:href="listings/listing-10.txt"/>
    <para>The example also demonstrates how information can be passed between actions.
      <code>XQueryServlet</code>
      (which is called implicitly because the URL ends with
      <code>.xq</code>) can save the results of the called XQuery to a request attribute instead of writing them to the HTTP output stream. It does so if it finds a request attribute
      <literal>xquery.attribute</literal>, which should contain the name of the attribute the output should be saved to.</para>
    <para>In the example above,
      <literal>xquery.attribute</literal>
      is set to
      <code>model</code>. This causes
      <code>XQueryServlet</code>
      to fill the request attribute
      <literal>model</literal>
      with the results of the XQuery it executes. The query result will not be written to the HTTP response as you would normally expect, the HTTP response body will just be empty.</para>
    <para>Likewise,
      <code>XSLTServlet</code>
      can take its input from a request attribute instead of parsing the HTTP request body. The name of the request attribute should be given in attribute
      <literal>xslt.model</literal>. XSLTServlet discards the current request content (which is empty anyway) and uses the data in the attribute's value as input for the transformation process.</para>
    <para>XSLTServlet will always write to the HTTP response. The second invocation of XSLTServlet therefore needs to read its input from the HTTP request body which contains the response of the first servlet. Since request attributes are preserved
      throughout the entire pipeline, we need to clear the
      <literal>xslt.input</literal>
      with an explicit call to clear-attribute.</para>
    <para>The benefit of exchanging data through request attributes is that we save one serialization step: <code>XQueryServlet</code> directly passes the node tree of its output as a valid XQuery value, so <code>XSLTServlet</code> does not need to parse it again.</para>
    <para>The advantages become more obvious if you have two or more XQueries which need to exchange information: XQuery 1 can use the XQuery extension function
      <code>request:set-attribute()</code>
      to save an arbitrary XQuery sequence to an attribute. XQuery 2 then calls
      <code>request:get-attribute()</code>
      to retrieve this value. It can directly access the data passed in from XQuery 1. No time is lost serializing/deserializing the data.</para>

    <para>Let's have a look at a more complex example: the XQuery sandbox web application needs to execute a user-supplied XQuery fragment. The results should be retrieved in an asynchronous way, so the user doesn't need to wait and the web interface
      remains usable.</para>
    <para>Older versions of the sandbox used the
      <literal>util:eval</literal>
      function to evaluate the query. However, this has side-effects because
      <code>util:eval</code>
      executes the query within the context of another query. Some features like module imports will not work properly this way. To avoid
      <code>util:eval</code>, the controller code below passes the user-supplied query to XQueryServlet first, then post-processes the returned result and stores it into a session for later use by the ajax frontend:</para>

    <programlisting language="xquery" xlink:href="listings/listing-11.txt"/>
    <para>The client passes the user-supplied query string in a request parameter, so the controller has to forward this to
      <code>XQueryServlet</code>
      somehow.
      <code>XQueryServlet</code>
      has an option to read the XQuery source from a request attribute,
      <literal>xquery.source</literal>. The query result will be saved to the attribute
      <literal>results</literal>. The second XQuery,
      <literal>session.xq</literal>, takes the result and stores it into a HTTP session, returning only the number of hits and the elapsed time.</para>
    <para>When called through retrieve,
      <literal>session.xq</literal>
      looks at parameter
      <literal>num</literal>
      and returns the item at the corresponding position from the query results stored in the HTTP session.</para>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="special-attributes">
    <title>Special Attributes Accepted by eXist Servlets</title>

    <para>eXist's
      <code>XQueryServlet</code>
      as well as the
      <code>XSLTServlet</code>
      will listen to a few predefined request attributes. The names of these attributes are listed below and should not be used for other purposes.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xq-servlet">
      <title>XQueryServlet</title>

      <variablelist>
        <varlistentry>
          <term>
            <code>xquery.attribute</code>
          </term>
          <listitem>
            <para>Contains the name of a request attribute. Instead of writing query results to the response output stream, XQueryServlet will store them into the named attribute. The value of the attribute will be an XQuery Sequence (<literal>org.exist.xquery.Sequence</literal>). If no query results were returned, the attribute will contain an empty sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.source</code>
          </term>
          <listitem>
            <para>If set, the value of this attribute must contain the XQuery code to execute. Normally,
              <code>XQueryServlet</code>
              reads the XQuery from the file given in the request path.
              <literal>xquery.source</literal>
              is a way to overwrite this behaviour, e.g. if you want to evaluate an XQuery which was generated within the controller.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.module-load-path</code>
          </term>
          <listitem>
            <para>The path which will be used for locating modules. This is only relevant in combination with
              <literal>xquery.source</literal>
              and tells the XQuery engine where to look for modules imported by the query. For example, if you stored required modules into the database collection
              <literal>/db/test</literal>, you can set
              <literal>xquery.module-load-path</literal>
              to
              <code>xmldb:exist:///db/test</code>. If the query contains an expression:</para>
            <programlisting language="xquery">import module namespace test="http://exist-db.org/test" at "test.xq";</programlisting>
            <para>the XQuery engine will try to find the module
              <literal>test.xq</literal>
              in the filesystem by default, which is not what you want. Setting
              <literal>xquery.module-load-path</literal>
              fixes this.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.report-errors</code>
          </term>
          <listitem>
            <para>If set to
              <code>yes</code>, an error in the XQuery will not result in an HTTP error. Instead, the string message of the error is enclosed in an element
              <tag>error</tag>
              which is then written to the response stream. The HTTP status is not changed.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xslt-servlet">
      <title>XSLTServlet</title>

      <variablelist>
        <varlistentry>
          <term>
            <code>xslt.stylesheet</code>
          </term>
          <listitem>
            <para>The path to the XSL stylesheet. Relative paths will be resolved against the current request URI, absolute paths against the context of the web application (/exist). To reference a stylesheet which is stored in the database, use an XML:DB URI like
              <literal>xmldb:exist:///db/styles/myxsl.xsl</literal>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.input</code>
          </term>
          <listitem>
            <para>Contains the name of a request attribute from which the input to the transformation process should be taken. The input has to be a valid eXist XQuery sequence.</para>
            <para>This attribute is usually combined with
              <literal>xquery.attribute</literal>
              provided by
              <code>XQueryServlet</code>
              and allows passing data between the two without additional serialization/parsing overhead.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.user</code>
          </term>
          <listitem>
            <para>The name of the eXist user to read and apply the stylesheet.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.password</code>
          </term>
          <listitem>
            <para>Password for the user given in
              <literal>xslt.user</literal>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <code>XSLTServlet</code>
        will attempt to map all other request attributes starting with the prefix
        <literal>xslt.</literal>
        into
        <emphasis>stylesheet parameters</emphasis>. So, for example, if you set a request attribute
        <literal>xslt.myattr</literal>
        it will be available within the stylesheet as parameter
        <literal>$xslt.myattr</literal>. For security reasons, this is the only way to pass request parameters into the stylesheet: use the controller query to transform the request parameter into a request attribute and pass that to the view.</para>
      <para>However, depending on the XSLT engine used, automatic conversion of types between eXist/Java and the XSLT processor may not always work. Best to limit your attribute values to strings.</para>
    </sect2>
  </sect1>
  <!-- ================================================================== -->
</article>