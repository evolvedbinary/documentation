<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
  version="5.0">
  <info>
    <title>URL Rewriting</title>
    <date>2023-03</date>
    <keywordset>
      <keyword>application-development</keyword>
    </keywordset>
  </info>

  <!-- ================================================================== -->
  <para>How to customize a web application's URLs using <code>controller.xq</code> scripts.</para>
  <!-- ================================================================== -->

  <sect1 xml:id="intro">
    <title>Introduction</title>
    <para>Good web applications provide meaningful and consistent URLs to the user. eXist-db's
        <emphasis>URL Rewriting</emphasis> facility is its oldest internal mechanism for providing
      short, human-readable URLs to XQuery web applications, conveniently masking the often complex
      heirarchy of XQuery modules, HTML files, data, and other resources. (A newer facility for
      achieving these goals is eXist-db's implementation of the <link
        xlink:href="http://exquery.github.io/exquery/exquery-restxq-specification/restxq-1.0-specification.html"
        >EXQuery RESTXQ specification</link>. A third method is to place a <link
        xlink:href="production_web_proxying">reverse proxy</link> between eXist-db and the end-user.
      Many applications combine two or even all three of these methods.)</para>
    <para>For a brief overview of how eXist-db's URL Rewriting facility works, consider what happens
      when eXist-db receives an HTTP request:</para>
    <orderedlist>
      <listitem>
        <para>eXist-db's Jetty web server receives an HTTP request. In the default configuration
          this is handled by the <code>XQueryUrlRewrite</code> servlet for any URL starting with the
          path <code>/exist</code>.</para>
      </listitem>
      <listitem>
        <para>The <code>XQueryUrlRewrite</code> servlet first checks the URL against a series of URL
          patterns defined in an eXist-db configuration file, called
            <literal>controller-config.xml</literal> and described in the section below on <link
            xlink:href="#controller-mappings">Base Mappings</link>. If eXist-db finds a matching
            <emphasis>root pattern</emphasis> (which by default is <code>/apps</code>), eXist-db
          will look within the associated <emphasis>controller root path</emphasis> (which by
          default is the <code>/db/apps</code> database collection), for <emphasis>controller
            scripts</emphasis>: special XQuery files named <code>controller.xq</code>. These
          controller scripts apply to the collections where they are stored and their descendant
          collections. They form a <emphasis>collection hierarchy</emphasis>â€”a URL space within
          which URL rewriting can be flexibly applied.</para>
      </listitem>
      <listitem>
        <para>The <code>controller.xq</code> script examines the URL using the provided <xref
            linkend="variables"/>, and produces an XML-formatted directive in the <xref
            linkend="controller-xml"/>.</para>
      </listitem>
      <listitem>
        <para>The <code>XQueryURLRewrite</code> servlet interprets the directive as a series of
          instructions for what to do next. These instructions may be as simple as forwarding the
          request to a resource on the server or redirecting a request to a new location. These
          instructions may be as complex as a pipeline using the
            <emphasis>Model-View-Controller</emphasis> pattern (see <xref linkend="mvc-pipelines"/>)
          and other servlets such as eXist-db's <xref linkend="xq-servlet"/> or <xref
            linkend="xslt-servlet"/>.</para>
      </listitem>
    </orderedlist>
    <sect2 xml:id="eg1">
      <title>Example 1: Simple URL Rewriting</title>
      <para>Consider the application you are currently using. You are likely accessing this article
        from the URL <code>/exist/apps/doc/urlrewrite</code>. But how is this possible? The
        underlying document in the eXist-db database is stored in a different location:
          <code>/exist/apps/doc/data/urlrewrite.xml</code>; this bears an extra <code>data</code>
        collection and an <code>.xml</code> file extension. If you access this "raw data" URL
        directly, eXist-db will return the XML document's content. A typical approach without URL
        rewriting to producing a properly formatted HTML page that they can easily consume in their
        web-browser would involve creating an XQuery to transform the XML into HTML. Let's call this
        query <literal>transform.xq</literal>. This query can dynamically transform documentation
        articles into HTML, but it needs to know which article the user is interested in. One way to
        provide a query with information it needs to select the right data is to append a URL
        parameter, such as <literal>doc</literal>, resulting in a URL like
          <code>/exist/apps/doc/modules/transform.xq?doc=urlrewrite.xml</code>. But this URL is
        cumbersome. How could we achieve the streamlined URL,
          <code>/exist/apps/doc/urlrewrite</code>?</para>
      <para>To achieve this goal we need a mechanism to map or rewrite a given URL to an application
        specific endpoint. Specifically, we need to ensure when a user visits the URL
          <code>/exist/apps/doc/urlrewrite</code>, eXist-db initiates an XQuery process that locates
        the source document, transforms it into HTML, and returns the HTML page. This control is
        precisely what the eXist-db URL Rewriting facility provides to application
        developers.</para>
      <para>The primary mechanism behind customizing URLs like this is the <emphasis>controller
          script</emphasis>, an XQuery main module named <literal>controller.xq</literal>. This
        script is invoked for all URL paths targeting the collection in which it resides. It has
        access to a number of <xref linkend="variables"/> pre-bound with details about the request,
        including <literal>$exist:resource</literal>, which conveniently contains the name of the
        requested resource (without any leading path components). It also includes
          <literal>$exist:controller</literal>, which contains the path to the database collection
        where the <literal>controller.xq</literal> is located.</para>
      <para>This information allows a controller script to forward all requests for
          <literal>/exist/apps/doc/{resource}</literal> to an XQuery,
          <literal>transform.xq</literal>, which converts the XML document located via the
          <literal>{resource}</literal> path component into an HTML page. To achieve this, one would
        create the following controler script and store it in the database at the path:
          <literal>/db/apps/doc/controller.xq</literal>:</para>
      <programlisting language="xquery" xlink:href="listings/listing-1.txt"/>
      <para>This example controller script returns a simple <tag>dispatch</tag> element which will
        be passed back to eXist-db's URL Rewriting framework. The <tag>forward</tag> element
        instructs the framework to call the URL <literal>modules/transform.xq</literal> relative to
        the collection where the controller resides. It adds an HTTP Request parameter, named
          <literal>doc</literal>, which constructs the resource that the
          <literal>transform.xq</literal> module will retrieve and transform. The
          <literal>transform.xq</literal> module will access the <literal>doc</literal> parameter by
        calling the <code>request:get-parameter()</code> XQuery function from eXist-db's HTTP
        Request Module, so that it can locate the desired resource.</para>
    </sect2>
    <sect2 xml:id="eg2">
      <title>Example 2: Defining a Pipeline</title>
      <para>Real world controllers are often far more complex and may contain arbitrary XQuery code
        to distinguish between different scenarios. The eXist-db URL Rewriting framework allows you
        to turn simple requests into complex processing pipelines, involving any number of
        steps.</para>
      <para>For example, let us split the <tag>dispatch</tag> element from above into a pipeline
        involving two steps:</para>
      <orderedlist>
        <listitem>
          <para>Load the resource to be transformed</para>
        </listitem>
        <listitem>
          <para>Pass the content of the resource to <literal>modules/transform.xq</literal></para>
        </listitem>
      </orderedlist>
      <programlisting language="xquery" xlink:href="listings/listing-2.txt"/>
      <para>Every <tag>dispatch</tag> element must contain at least one <tag>forward</tag> element,
        followed by an optional <tag>view</tag> element, grouping any number of follow up steps. In
        this example, the first <tag>forward</tag> element simply instructs eXist-db to load the
        requested XML document and then return its content. The output of the first step is passed
        internally via the HTTP request to the second step. The <literal>transform.xq</literal>
        module can access this output via the <code>request:get-data()</code> XQuery function from
        eXist-db's HTTP Request Module.</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->
  <sect1 xml:id="controller-xml">
    <title>Controller XML Format</title>
    <para>As we have seen, the <code>controller.xq</code> script is expected to return a single XML
      element: either a <tag>dispatch</tag> element or an <tag>ignore</tag> element.</para>
    <para>Note that all of the elements discussed in this article must be in the
        <code>http://exist.sourceforge.net/NS/exist</code> namespace.</para>
    <sect2 xml:id="dispatch">
      <title>The <tag>dispatch</tag> Action</title>
      <para>The <tag>dispatch</tag> element must contain one of the <emphasis>action
          elements</emphasis>
        <link linkend="redirect"><literal>redirect</literal></link> or <link linkend="forward"
            ><literal>forward</literal></link>, followed by an optional <link linkend="view"
            ><literal>view</literal></link> element. It may also contain an optional <link
          linkend="cache-control"><literal>cache-control</literal></link> element.</para>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  ...
&lt;/dispatch&gt;</programlisting>
    </sect2>
    <sect2 xml:id="ignore">
      <title>The <tag>ignore</tag> Action</title>
      <para>The <tag>ignore</tag> action simply bypasses the URL Rewriting facility. This may be
        useful for requests to fixed resources like images or stylesheets. An alternative may be to
        handle requests for such resources separately from the <code>XQueryUrlRewrite</code>
        servlet; this is discussed in <xref linkend="controller-mappings"/>.</para>
      <programlisting language="xml">&lt;ignore xmlns="http://exist.sourceforge.net/NS/exist"/&gt;</programlisting>
      <para>The <tag>ignore</tag> element may include an optional <link linkend="cache-control"
            ><literal>cache-control</literal></link> element.</para>
    </sect2>
    <sect2 xml:id="redirect">
      <title>The <tag>redirect</tag> Action</title>
      <para>The <tag>redirect</tag> action redirects the client to another URL with an <link
          xlink:href="https://www.rfc-editor.org/rfc/rfc2616.html#section-10.3.3">HTTP 302 redirect
          response</link>, indicating that the requested resource has been temporarily moved to a
        new URL (supplied by the Location HTTP Header). Clients typically follow the redirect and
        issue a request to the new URL; users will see their web browser update and show the new
        URL. Note that this second request may well access the eXist-db controller again; care must
        be taken to avoid creaing an infinite loop.</para>
      <para>The <tag>redirect</tag> element must contain a <literal>url</literal> attribute:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>url</code>
          </term>
          <listitem>
            <para>The URL to redirect the request to.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;redirect url="..."/&gt;
&lt;/dispatch&gt;</programlisting>
      <para>Many eXist-db applications establish redirects for requests to their root without a
        leading slash, to ensure that all subsequent requests to the application begin with a
        leading slash. This is often accomplished as the first condition in the
          <literal>controller.xq</literal> script:</para>
      <programlisting language="xquery" xlink:href="listings/listing-14.txt"/>
      <para>In a local copy of the eXist-db Documentation application, for example, this will cause
        a request for <literal>http://localhost:8080/exist/apps/doc</literal> to receive the
        following HTTP 302 redirect response:</para>
      <programlisting>HTTP/1.1 302 Found
Location: http://localhost:8080/exist/apps/doc/
Content-Length: 0</programlisting>
    </sect2>
    <sect2 xml:id="forward">
      <title>The <tag>forward</tag> Action</title>
      <para>The <tag>forward</tag> action internally forwards the current request to another request
        path or servlet. Unlike the <literal>redirect</literal> action, the
          <literal>forward</literal> action is performed entirely server-side by eXist-db (via the
          <code>RequestDispatcher</code> of the servlet engine). The details of the internal forward
        action are not exposed to the client; i.e., the user's web browser will not show any changes
        to the URL.</para>
      <para>The <tag>forward</tag> element must contain either a <literal>url</literal> or
          <literal>servlet</literal> attribute:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>url</code>
          </term>
          <listitem>
            <para>The new request path, which will be processed by the servlet engine in the normal
              way, as if it were directly called.</para>
            <para>If a relative path is provided, then it is resolved relative to to the current
              request path. An absolute path will be resolved relative to the path that triggered
              the controller.</para>
            <para>For example, if the current URL context is <literal>/exist</literal> and the
              supplied attribute reads <literal>url="/admin"</literal>, the resulting path will be
                <literal>/exist/admin</literal>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>servlet</code>
          </term>
          <listitem>
            <para>The name of a servlet as given in the <tag>servlet-name</tag> element of the
              corresponding servlet definition from eXist-db's web descriptor
                <literal>$EXIST_HOME/etc/webapp/WEB-INF/web.xml</literal> configuration file. </para>
            <para>For example, valid names within the eXist-db's standard setup would be
                <code>XQueryServlet</code> or <code>XSLTServlet</code>. You can see some examples of
              these in the article <xref linkend="mvc-pipelines"/>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>The <tag>forward</tag> element may contain the following optional attributes:</para>
      <variablelist>
        <varlistentry>
          <term>
            <code>absolute</code>
          </term>
          <listitem>
            <para>To be used in combination with <literal>url</literal>. If set to "yes", the url
              will be interpreted as an absolute path within the current servlet context. See <xref
                linkend="EXTERNAL_RESOURCES"/> for an example.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>method</code>
          </term>
          <listitem>
            <para>The HTTP method (e.g., POST, GET, PUT) to use when passing the request to the next
              step in the pipeline; not applicable to the first step. The default method for
              pipeline steps in the view section is always <literal>POST</literal>.</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;forward url="{$exist:controller}/modules/transform.xq"&gt;
    &lt;add-parameter name="doc" value="{$exist:resource}.xml"/&gt;
  &lt;/forward&gt;
&lt;/dispatch&gt;</programlisting>
      <para>The <tag>forward</tag> element can contain the optional child elements: <link
          linkend="add-parameter"><literal>add-parameter</literal></link>, <link
          linkend="set-attribute"><literal>set-attribute</literal></link>, <link
          linkend="clear-attribute"><literal>clear-attribute</literal></link>, and <link
          linkend="set-header"><literal>set-header</literal></link>.</para>
    </sect2>
    <sect2 xml:id="view">
      <title>The <tag>view</tag> Action</title>
      <para>The <tag>view</tag> action is used to define processing pipelines, and may follow <link
          linkend="redirect"><literal>redirect</literal></link> or <link linkend="forward"
            ><literal>forward</literal></link> actions.</para>
      <para>The <tag>view</tag> element is used to wrap a sequence of action elements such as <link
          linkend="forward"><literal>forward</literal></link>. It is often used to call another
        servlet to process the results of the initial action. This is discussed in the article:
          <xref linkend="mvc-pipelines"/></para>
    </sect2>
    <sect2 xml:id="add-parameter">
      <title>The <tag>add-parameter</tag> Option</title>
      <para>The <tag>add-parameter</tag> option adds (or overwrites) a HTTP Request
        Parameter.</para>
      <para>The name of the parameter is taken from the <literal>name</literal> attribute, and the
        value from the <literal>value</literal> attribute.</para>
      <programlisting language="xml">&lt;add-parameter name="xxx" value="yyy"/&gt;</programlisting>
      <para>The original HTTP request will be copied before the change is applied. This applies only
        to the step on which it is placed, that is to say that subsequent steps in the pipeline will
        not see the parameter.</para>
      <para>To access the value of the parameter, use the <code>request:get-parameter()</code>
        XQuery function from eXist-db's HTTP Request Module.</para>
    </sect2>
    <sect2 xml:id="set-attribute">
      <title>The <tag>set-attribute</tag> Option</title>
      <para>The <tag>set-attribute</tag> option adds (or overwrites) a Java Servlet request
        attribute. They are part of the Java Servlet specification, and are not related to the HTTP
        Request or HTTP Response. Request attribute are internal to the pipeline. Unlike request
        parameters, request attributes will be visible to subsequent steps in the processing
        pipeline.</para>
      <para>The name of the request attribute is read from the <literal>name</literal> attribute,
        and the value from the <literal>value</literal> attribute.</para>
      <programlisting language="xml">&lt;set-attribute name="xxx" value="yyy"/&gt;</programlisting>
      <para>You can set arbitrary request attributes, for instance to pass information between
        XQuery modules. Some attribute names may be reserved by various servlets in the
        pipeline.</para>
      <para>To access the value of the request attribute, use the
          <code>request:get-attribute()</code> XQuery function from eXist-db's HTTP Request
        Module.</para>
    </sect2>
    <sect2 xml:id="clear-attribute">
      <title>The <tag>clear-attribute</tag> Option</title>
      <para>The <tag>clear-attribute</tag> option clears a request attribute.</para>
      <para>The name of the request attribute is read from the <literal>name</literal>
        attribute.</para>
      <programlisting language="xml">&lt;clear-attribute name="xxx"/&gt;</programlisting>
      <para>Since request attributes will be visible to subsequent steps in the processing pipeline,
        you may wish to clear them once they are no longer needed. eXist-db places no requirement on
        the user having to ever clear attributes.</para>
    </sect2>
    <sect2 xml:id="set-header">
      <title>The <tag>set-header</tag> Option</title>
      <para>The <tag>set-header</tag> option sets an HTTP Response Header field.</para>
      <para>The name of the header is read from the <literal>name</literal> attribute, and the value
        from the <literal>value</literal> attribute.</para>
      <programlisting language="xml">&lt;set-header name="xxx" value="yyy"/&gt;</programlisting>
      <para>The HTTP response is shared between all steps in the pipeline, so all following steps
        will be able to see the change.</para>
    </sect2>
    <sect2 xml:id="cache-control">
      <title>The <tag>cache-control</tag> Option</title>
      <para>The <tag>cache-control</tag> element is used to tell the URL Rewriting framework if the
        mapping used to rewrite the input URL to its dispatch rule should be cached. It has a single
        attribute: <literal>cache="yes|no"</literal>. </para>
      <para>Internally the URL Rewriting framework maintains a mapping between input URLs and
        dispatch rules. When the cache is enabled, the <literal>controller.xq</literal> script only
        needs to be executed once for each distinct input URL. Subsequent requests for the same URL
        will be served from the cache.</para>
      <programlisting language="xml">&lt;dispatch xmlns="http://exist.sourceforge.net/NS/exist"&gt;
  &lt;redirect url="..."/&gt;
  &lt;cache-control cache="yes"/&gt;
&lt;/dispatch&gt;</programlisting>
      <para>Note: Only the URL rewrite rule is cached. The HTTP response itself is not cached. The
          <literal>cache-control</literal> setting is completely unrelated to HTTP Cache Headers in
        the HTTP Response and any client-side caching within a web browser.</para>
    </sect2>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="variables">
    <title>Controller Variables</title>
    <para>Five URL Rewriting-related variables are pre-bound and made available to the
        <code>controller.xq</code> script for convenience. For example, if the request path is
        <literal>/exist/apps/sandbox/get-examples.xq</literal> these variables will be bound to the
      following values:</para>
    <table>
      <title>Table title</title>
      <tgroup cols="2">
        <colspec/>
        <colspec/>
        <thead>
          <row>
            <entry>
              <para>Variable Name</para>
            </entry>
            <entry>
              <para>Variable Value</para>
            </entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>
              <para>
                <literal>$exist:root</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>xmldb:exist:///db/apps</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:prefix</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/apps</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:controller</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/sandbox</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:path</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>/get-examples.xq</literal>
              </para>
            </entry>
          </row>
          <row>
            <entry>
              <para>
                <literal>$exist:resource</literal>
              </para>
            </entry>
            <entry>
              <para>
                <literal>get-examples.xq</literal>
              </para>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>These variables are pre-bound for simplicity and convenience. You do not need to
      explicitly declare the variables or the <literal>exist</literal> namespace. However, doing so
      is considered best practice, by adding this block to the prolog of your
        <literal>controller.xq</literal> script. For instance:</para>
    <programlisting language="xquery">declare namespace exist="http://exist.sourceforge.net/NS/exist";

declare variable $exist:root external;
declare variable $exist:prefix external;
declare variable $exist:controller external;
declare variable $exist:path external;
declare variable $exist:resource external;
</programlisting>
    <para>These variables can also be accessed by any query within the controller hierarchy via the
        <literal>request:get-attribute()</literal> function, e.g.,
        <literal>request:get-attribute("$exist:prefix")</literal>.</para>
    <para>Some further remarks about each variable:</para>
    <variablelist>
      <varlistentry>
        <term>
          <code>exist:root</code>
        </term>
        <listitem>
          <para>Is bound to the root of the current controller hierarchy. This may either point to
            the file system or to a collection in the database. You can use this variable to locate
            resources relative to the root of the application.</para>
          <para>For example, assume that you want to process a request using stylesheet
              <literal>db2xhtml.xsl</literal>, which could <emphasis>either</emphasis> be stored in
            the <literal>/stylesheets</literal> directory in the root of the webapp or, if the app
            is running from within the database, the corresponding <literal>/stylesheets</literal>
            collection. You want your app to be able to run from either location. The solution is to
            incorporate the value of the <literal>exist:root</literal> variable into your
            logic:</para>
          <programlisting language="xml" xlink:href="listings/listing-5.xml"/>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:prefix</code>
        </term>
        <listitem>
          <para>If the current controller hierarchy is mapped to a certain path prefix, then the
              <literal>$exist:prefix</literal> variable will be bound to that prefix.</para>
          <para>For example: the default configuration maps the path <literal>/apps</literal> to a
            collection in the database (see below). In this case, the
              <literal>$exist:prefix</literal> variable would be bound to the value
              <literal>/apps</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:controller</code>
        </term>
        <listitem>
          <para>Is bound to the part of the URL leading to the current
              <literal>controller.xq</literal>.</para>
          <para>For example, if the request path is <literal>/sandbox/test.xq</literal> and the
            controller is in the <literal>xquery</literal> collection, the
              <literal>$exist:controller</literal> variable will be bound to the value
              <literal>/sandbox</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>
          <code>exist:path</code>
        </term>
        <listitem>
          <para>Is bound to the last part of the request URL, i.e., after the section leading to the
            collection containing the controller.xq.</para>
          <para>For instance, if the resource <literal>example.xml</literal> resides within the same
            collection as the controller query, the <literal>$exist:path</literal> variable would be
            bound to the value <literal>/example.xml</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term><code>exist:resource</code></term>
        <listitem>
          <para>Is bound to the part of the URL after the last <literal>/</literal>; this is usually
            pointing to a resource.</para>
          <para>For instance: <literal>example.xml</literal>.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>In addition, within a <code>controller.xq</code> file, you also have access to the entire
      XQuery function library, including the functions in the HTTP <code>request</code>,
        <code>response</code>, and <code>session</code> modules.</para>
  </sect1>

  <!-- ================================================================== -->
  <sect1 xml:id="EXTERNAL_RESOURCES">
    <title>Accessing Resources Not Stored in the Database</title>
    <para>If your <code>controller.xq</code> is stored in a database collection, all relative and/or
      absolute URLs processed by the controller will be resolved against the database, not the file
      system. This can be a problem if you need to access common resources, which should be shared
      with other applications residing on the file system or in the database.</para>
    <para>The <link linkend="forward"><literal>forward</literal></link> directive accepts an
      optional attribute <literal>absolute="yes|no"</literal> to handle this. If one sets
        <literal>absolute="yes"</literal>, an absolute path (starting with a <code>/</code>) in the
        <literal>url</literal> attribute will resolve relative to the current servlet context, not
      the controller context.</para>
    <para>For example, to forward all requests starting with a path <literal>/libs/</literal> to a
      directory within the <literal>webapp</literal> folder of eXist-db, you can build upon the
      following example snippet:</para>
    <programlisting language="xquery" xlink:href="listings/listing-12.txt"/>
    <para>This simply removes the <literal>/libs/</literal> prefix and sets the attribute
        <literal>absolute="yes"</literal>, so that the path will be resolved relative to the main
      context of the servlet engine, typically <literal>/exist/</literal>. In your HTML, you can now
      write paths such as:</para>
    <programlisting language="xml" xlink:href="listings/listing-13.xml"/>
    <para>This will locate the jquery file in <literal>webapp/scripts/jquery/...</literal>, even if
      the rest of your application is stored in the db and not on the file system.</para>
  </sect1>
  <!-- ================================================================== -->

  <sect1 xml:id="controller-mappings">
    <title>Locating Controller Scripts and Configuring Base Mappings</title>

    <para>By convention, the controller script must be named <literal>controller.xq</literal> (or in
      older applications <code>controller.xql</code>). If you wish to allow anonymous users to
      access resources using the URL Rewriting framework then you need to ensure that the
        <literal>controller.xq</literal> script is world-executable, e.g.,
        <code>sm:chmod(xs:anyURI("/path/to/controller.xq")), "o+x")</code>.</para>
    <para>By default, the URL Rewriting framework will try to guess the path to the controller
      script by looking at the request path, starting with the deepest, most specific collection,
      and then looking into each parent collection until the controller script is found or the root
      of the database has been reached.</para>
    <para>This can be configured and overridden via the <literal>controller-config.xml</literal>
      configuration file in <literal>$EXIST_HOME/etc/webapp/WEB-INF</literal>, which defines the
      base mappings used.</para>
    <para>In fact, one web application may have more than one controller hierarchy. For example, you
      may want to keep the main webapp within the file system, while some tools and scripts should
      be served from a database collection. This can be done by configuring two roots within the
        <literal>controller-config.xml</literal> file.</para>
    <para>The configuration file has two components:</para>
    <itemizedlist>
      <listitem>
        <para>
          <tag>forward</tag> actions which map URL patterns to servlets</para>
      </listitem>
      <listitem>
        <para>
          <tag>root</tag> elements that define the root for a file system or database collection
          hierarchy</para>
      </listitem>
    </itemizedlist>
    <para>The <tag>forward</tag> elements specify path mappings for common servlets, similar to the
      servlet mapping in <literal>$EXIST_HOME/etc/webapp/WEB-INF/web.xml</literal>. The advantage to
      specifying them in <literal>controller-config.xml</literal> is that the XQueryURLRewrite
      servlet (which implements the URL Rewriting framework) becomes a single point of entry for the
      entire web application, and no additional handling of the servlet paths is necessary in the
      controller script.</para>
    <para>For example, if we had registered a servlet mapping for <literal>/rest</literal> in
        <literal>web.xml</literal>, we would jave needed to make sure that this path is ignored in
      our main <literal>controller.xq</literal> scripts. However, since the mapping is done via
        <literal>controller-config.xml</literal>, XQueryURLRewrite handles the path, which then
      doesn't need to be accounted for in our controller.</para>
    <para>The <tag>root</tag> elements define the roots of a directory or database collection
      hierarchy, mapped to a certain base path. For example, the default
        <literal>controller-config.xml</literal> uses two roots:</para>
    <programlisting language="xml" xlink:href="listings/listing-7.txt"/>
    <para>This means that paths starting with <literal>/apps</literal> will be mapped to the
      collection hierarchy below <literal>/db/apps</literal>. All relative or absolute URLs within
      the URL space managed by the <literal>controller.xq</literal> script will be resolved against
      the database, not the file system. Everything else is handled by the catch all pattern
      pointing to the root directory of the webapp (which, by default, corresponds to
        <literal>$EXIST_HOME/etc/webapp</literal>). However, there's a possibility to escape this
      path interpretation as described <link xlink:href="#EXTERNAL_RESOURCES">below</link>.</para>
  </sect1>
  <!-- ================================================================== -->

  <sect1 xml:id="mvc-pipelines">
    <title>MVC and Pipelines</title>

    <para>The <code>XQueryURLRewrite</code> servlet does more than just forward or redirect
      requests: the response can be processed by passing it to a pipeline of views. "Views" are
      again just plain Java servlets. The most common use of a view would be to post-processes the
      XML returned from the primary URL, either through another XQuery or an XSLT stylesheet
        (<code>XSLTServlet</code>). <code>XQueryURLRewrite</code> passes the HTTP response stream of
      the previous servlet to the HTTP request received by the next servlet. It is fully possible to
      extend eXist-db by adding in your custom own servlets.</para>
    <para>Views may also directly exchange information through the use of request attributes (more
      on that below).</para>

    <para>You define a view pipeline by adding a <tag>view</tag> element to the <tag>dispatch</tag>
      element returned by the controller. The <tag>view</tag> element is a wrapper around another
      sequence of <tag>forward</tag> or <tag>rewrite</tag> actions.</para>
    <para>For example, assume we have some XML documents written in DocBook format, and that we wish
      to render this as HTML by transforming the XML to HTML through an XSLT stylesheet
        <literal>webapp/stylesheets/db2html.xsl</literal>. This can be done by returning the
      following <tag>dispatch</tag> element from a <literal>controller.xq</literal>:</para>
    <programlisting language="xml" xlink:href="listings/listing-9.xml"/>
    <para>In this example there are no forwarding actions except for the view, so the request will
      be handled by the servlet engine in the default way. The response is then passed to the
        <code>XSLTServlet</code>. A new HTTP POST request is created whose body is set to the
      response data of the previous step. The <code>XSLTServlet</code> gets the path to the
      stylesheet from the request attribute <code>xslt.stylesheet</code> and applies it to the
      provided data.</para>
    <para>If any step in the pipeline generates an error or returns an HTTP status code &gt;= 400,
      the pipeline processing stops and the response is send back to the client immediately. The
      same happens if the first step returns with an HTTP status 304 (NOT MODIFIED), which indicates
      that the client can use the version it has cached.</para>
    <para>We can also pass a request through more than one view. The following document applies two
      stylesheets in sequence:</para>

    <programlisting language="xquery" xlink:href="listings/listing-10.txt"/>
    <para>The example also demonstrates how information can be passed between actions.
        <code>XQueryServlet</code> (which is called implicitly because the URL ends with
        <code>.xq</code>) can save the results of the called XQuery to a request attribute instead
      of writing them to the HTTP output stream. It does so if it finds a request attribute named
        <literal>xquery.attribute</literal>, which should in turn contain the name of the request
      attribute that the output should be saved to.</para>
    <para>In the example above, <literal>xquery.attribute</literal> is set to <code>model</code>.
      This causes <code>XQueryServlet</code> to fill the request attribute <literal>model</literal>
      with the results of the XQuery it executes. The query result will not be written to the HTTP
      response as you might expect, instead at this point the HTTP response body remains empty as
      the data is inside the request attribute.</para>
    <para>Likewise, <code>XSLTServlet</code> can take its input from a request attribute instead of
      parsing the HTTP request body. The name of the request attribute should be given in attribute
        <literal>xslt.model</literal>. XSLTServlet discards the current request content (which is
      empty anyway) and uses the data in the attribute's value as input for the transformation
      process.</para>
    <para><literal>XSLTServlet</literal> will always write to the HTTP response. The second
      invocation of <literal>XSLTServlet</literal> therefore needs to read its input from the HTTP
      request body which contains the response of the first servlet. Since request attributes are
      preserved throughout the entire pipeline, we need to clear the <literal>xslt.input</literal>
      with an explicit call to <literal>clear-attribute</literal>.</para>
    <para>The benefit of exchanging data through request attributes is that we save one
      serialization step: <code>XQueryServlet</code> directly passes the node tree of its output as
      a valid XQuery value, so <code>XSLTServlet</code> does not need to parse it again.</para>
    <para>The advantages become more obvious if you have two or more XQueries which need to exchange
      information: XQuery 1 can use the XQuery extension function
        <code>request:set-attribute()</code> to save an arbitrary XQuery sequence to an attribute.
      XQuery 2 then subsequently calls <code>request:get-attribute()</code> to retrieve this value.
      As it can directly access the data passed in from XQuery 1, no time is lost serializing and
      deserializing the data.</para>

    <para>Let's have a look at a more complex example: eXist-db's eXide web application needs to
      execute a user-supplied XQuery fragment. The results should be retrieved in an asynchronous
      way, so the user doesn't need to wait and the web interface remains usable.</para>
    <para>Older versions of eXide's ancestor sandbox application used the
        <literal>util:eval()</literal> function to evaluate the query. However, this had
      side-effects because <code>util:eval()</code> executes the query within the context of the
      parent query. Some features like module imports could not work properly. To avoid
        <code>util:eval()</code>, the controller code below passes the user-supplied query to
        <literal>XQueryServlet</literal> first, then post-processes each returned result and stores
      it into a session for later use by the AJAX frontend:</para>

    <programlisting language="xquery" xlink:href="listings/listing-11.txt"/>
    <para>The client passes the user-supplied query string in a request parameter, so the controller
      has to forward this to <code>XQueryServlet</code> somehow. <code>XQueryServlet</code> has an
      option to read the XQuery source from a request attribute, <literal>xquery.source</literal>.
      The query result will be saved to the attribute <literal>results</literal>. The second XQuery,
        <literal>session.xq</literal>, takes the result and stores it into an HTTP session,
      returning only the number of hits and the elapsed time.</para>
    <para>When called through retrieve, <literal>session.xq</literal> looks at parameter
        <literal>num</literal> and returns the item at the corresponding position from the query
      results stored in the HTTP session.</para>
  </sect1>

  <!-- ================================================================== -->

  <sect1 xml:id="special-attributes">
    <title>Special Attributes Accepted by eXist-db Servlets</title>

    <para>eXist-db's <code>XQueryServlet</code> as well as the <code>XSLTServlet</code> expect a few
      predefined request attributes. The names of these attributes are listed below, and are
      reserved, that is to say that they should not be used for other purposes.</para>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xq-servlet">
      <title>XQueryServlet</title>

      <variablelist>
        <varlistentry>
          <term>
            <code>xquery.attribute</code>
          </term>
          <listitem>
            <para>Contains the name of a request attribute. Instead of writing query results to the
              response output stream, <literal>XQueryServlet</literal> will store them into the
              named attribute. The value of the attribute will be an XQuery Sequence. If no query
              results were returned, the attribute will contain an empty sequence.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.source</code>
          </term>
          <listitem>
            <para>If set, the value of this attribute must contain the XQuery code to execute.
              Normally, <code>XQueryServlet</code> reads the XQuery from the file given in the
              request path. Use of the <literal>xquery.source</literal> attribute allows you to
              overwrite this behaviour, e.g. if you want to evaluate an XQuery which was generated
              within the controller.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.module-load-path</code>
          </term>
          <listitem>
            <para>The path which will be used for locating modules. This is only relevant in
              combination with <literal>xquery.source</literal> and tells the XQuery engine where to
              look for modules imported by the query. For example, if you stored required modules
              into the database collection <literal>/db/test</literal>, you can set
                <literal>xquery.module-load-path</literal> to <code>xmldb:exist:///db/test</code>.
              If the query contains an expression:</para>
            <programlisting language="xquery">import module namespace test="http://exist-db.org/test" at "test.xq";</programlisting>
            <para>The XQuery engine will try to find the module <literal>test.xq</literal> in the
              filesystem by default, which may not be what you were expecting! Setting the
                <literal>xquery.module-load-path</literal> allows you to configure this.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xquery.report-errors</code>
          </term>
          <listitem>
            <para>If set to <code>yes</code>, an error in the XQuery will not result in an HTTP
              error. Instead, the string message of the error is enclosed in an element
                <tag>error</tag> and then written to the response stream. The HTTP Response's Status
              Code will remain unchanged.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

    <sect2 xml:id="xslt-servlet">
      <title>XSLTServlet</title>

      <variablelist>
        <varlistentry>
          <term>
            <code>xslt.stylesheet</code>
          </term>
          <listitem>
            <para>The path to the XSLT stylesheet. Relative paths will be resolved against the
              current request URL, absolute paths against the context of the web application
                (<literal>/exist</literal>). To reference a stylesheet which is stored in the
              database, use an XML:DB URL like
                <literal>xmldb:exist:///db/styles/myxsl.xslt</literal>.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.input</code>
          </term>
          <listitem>
            <para>Contains the name of a request attribute from which the input to the
              transformation process should be taken. The input has to be a valid eXist-db XQuery
              Sequence.</para>
            <para>This attribute is usually combined with the <literal>xquery.attribute</literal>
              attribute provided by <code>XQueryServlet</code> and allows passing data between the
              two without additional serialization or deserialization overhead.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.user</code>
          </term>
          <listitem>
            <para>The name of the eXist -db user account to use when reading and executing the
              stylesheet.</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>
            <code>xslt.password</code>
          </term>
          <listitem>
            <para>The password for the user given in <literal>xslt.user</literal>
            </para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>
        <code>XSLTServlet</code> will attempt to map all other request attributes starting with the
        prefix <literal>xslt.</literal> into <emphasis>stylesheet parameters</emphasis>. So, for
        example, if you set a request attribute <literal>xslt.myattr</literal> it will be available
        within the stylesheet as parameter <literal>$xslt.myattr</literal>. For security reasons,
        this is the only way to pass request parameters into the stylesheet; you can use your
          <literal>controller.xq</literal> to transform a HTTP Request parameter into a request
        attribute and pass that on to the view.</para>
    </sect2>
  </sect1>
  <!-- ================================================================== -->
</article>
